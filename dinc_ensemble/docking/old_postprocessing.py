from copy import deepcopy
from numpy import array
from numpy.linalg import norm

# Import matplotlib and fix display issue in Tkinter
#from matplotlib import use as matplotUse
#matplotUse("Agg")
from AutoDockTools.Docking import Docking
from MolKit.molecule import AtomSet
from MolKit import Read as MolKitRead
from mglutil.math.statetocoords import StateToCoords
from AutoDockTools.Conformation import Conformation

from dinc_ensemble.receptor.receptor_prepare import remove_flex_from_output
from dinc_ensemble.utils import terminate

from .old_scoring import rescore


# Process the docking results stored in the given docking files.
# Return the binding modes without steric clashes, sorted by increasing energy.
#   bonded_atoms: dictionary listing, for each ligand's atom, the atoms it shares a bond with
#   receptor_file: name of the pdbqt file containing the receptor's description
#   params: parameters of the docking job
#   dir_path: directory containing the docking files
#   final: boolean value indicating if the docking results come from the final docking round
#   enforce_quit: if set to True, the whole program terminates in case of problem
#
def process_docking_output(
    docking_files,
    ligand,
    bonded_atoms,
    receptor_file,
    params,
    dir_path,
    final=True,
    enforce_quit=True,
):
    # read the ligand conformations stored in the docking files
    conformations = []
    for file in docking_files:
        if params["sampling"] == "AD4":
            conformations.extend(extract_AD4_conformations(file, params))
        elif params["sampling"] == "Vina":
            conformations.extend(extract_Vina_conformations(file, params))

    # select the conformations that do not contain any steric clash
    valid_conformations = select_clash_free_confs(conformations, bonded_atoms)
    if not valid_conformations:
        if not enforce_quit:
            return valid_conformations
        print(
            "DincError: DINC couldn't generate binding modes for this job. Please try again."
        )
        terminate(dir_path)

    # sort the conformations by increasing energy (which might require to re-score them)
    if final:
        if params["rescoring"] != params["sampling"]:
            rescore(
                valid_conformations,
                params["rescoring"],
                ligand.name,
                receptor_file,
                params,
                dir_path,
            )
    else:
        if params["scoring"] != params["sampling"]:
            rescore(
                valid_conformations,
                params["scoring"],
                ligand.name,
                receptor_file,
                params,
                dir_path,
            )

    valid_conformations.sort(key=lambda c: c.binding_energy)
    return valid_conformations


# Return the list of clash-free conformations belonging to the given set of conformations.
#   bonded_atoms: dictionary listing, for each ligand's atom, the atoms it shares a bond with
#
def select_clash_free_confs(conformationSet, bonded_atoms):
    clash_free_confs = []
    for conf in conformationSet:
        clash = False
        conf.mol.allAtoms.updateCoords(conf.coords, 0)
        atomList = list(conf.mol.allAtoms.get(lambda a: a.element != "H"))
        while atomList:
            atom = atomList.pop(0)
            for at in atomList:
                if at.name not in bonded_atoms[atom.name]:
                    dist = norm(array(atom.coords) - array(at.coords))
                    if dist < 1.2 * (atom.bondOrderRadius + at.bondOrderRadius):
                        clash = True
                        break
            if clash:
                break
        if not clash:
            clash_free_confs.append(conf)

    return clash_free_confs


# Extract the binding modes generated by Vina from the given docking file
# Return an array containing the extracted conformations
#   params: parameters of the docking job
#
def extract_Vina_conformations(docking_file, params):
    if not docking_file.endswith("_out.pdbqt"):
        docking_file += "_out.pdbqt"
    ligands = MolKitRead(docking_file)
    ligand = ligands[0]
    end = next(i for i, l in enumerate(ligand.parser.allLines) if l == "ENDMDL\n")
    ligand.parser.allLines = ligand.parser.allLines[2:end]
    res_codes = []
    if params["flex"]:
        res_codes = list(set(ligand.parser.mol.flex_res_list))

    conformations = []
    for l in ligands:
        flex_res = []
        if params["flex"]:
            rm_atoms = []
            for res in res_codes:
                [res_name, chain_code, res_num] = res.split()
                chain = l.chains[l.chains.name.index(chain_code)]
                residue = chain.residues[chain.residues.name.index(res_name + res_num)]

                # build bonds in residue
                # for some reason, the new confs are missing CA when they are written to a file
                # even though they are in the output confs
                residue.buildBondsByDistance()
                rm_atoms.extend(residue.atoms)
                flex_res.append(residue)
            l.allAtoms = l.allAtoms - AtomSet(rm_atoms)

        l.ROOT = ligand.ROOT
        l.torTree = ligand.torTree
        l.TORSDOF = len(l.torTree.torsionMap)
        l.stoc = StateToCoords(l, [0, 0, 0], 0)
        c = Conformation(l, [0, 0, 0], [0, 0, 0], [1, 0, 0, 0], [0] * l.TORSDOF)
        c.getCoords()
        c.flex_res = flex_res
        c.binding_energy = l.vina_energy
        conformations.append(c)

    return conformations


# Extract the binding modes generated by AutoDock4 from the given docking file
# Return an array containing the extracted conformations
#   params: parameters of the docking job
#
def extract_AD4_conformations(file, params):
    if not file.endswith(".dlg"):
        file += ".dlg"
    docking = Docking()

    docking.readDlg(file)
    confs = docking.ch.conformations

    # remove flexible residues from molecule
    if params["flex"]:
        # read in conformations without the flexible residue:
        # to get the correct coords
        new_file = remove_flex_from_output(file, params)
        docking = Docking()
        docking.readDlg(new_file)
        noflex_confs = docking.ch.conformations

        # remove atoms from new conf list
        # and get residues to add to separate attribute
        oldCoords = confs[0].mol.allAtoms.coords[:]
        res_codes = params["flex_res"].split(",")
        for c1, c2 in zip(confs, noflex_confs):
            c = deepcopy(c1)
            c.mol.allAtoms.updateCoords(c.coords, 0)
            flex_res = []
            rm_atoms = []
            for res in res_codes:
                [chain_code, res_code] = res.split(":")
                chain = c.mol.chains[c.mol.chains.id.index(chain_code)]
                residue = chain.residues[chain.residues.number.index(res_code)]
                residue.buildBondsByDistance()
                flex_res.append(residue)
                rm_atoms.extend(residue.atoms)
            c2.flex_res = flex_res
            c.mol.allAtoms = c.mol.allAtoms - AtomSet(rm_atoms)
            c2.mol = c.mol
        confs = noflex_confs
    return confs
